#Code sample from DragonPaint, a computer vision/graphics/machine learning program for automating sketch painting, in progress.
#K.G.Greene
#9/11/17

# class SketchComponents
# Label connected components labeled with scimage.measure.label
# BACKGROUND v. BODY v. SPIKES Find areas of white components to get background and body and spikes+.
# SPIKES v. EYE Find distance between component and background to distinguish eye from spikes.

#Code shown allows creation of labels for background, body, spikes and eye for a cartoon dragon sketch to allow 
#"paint by body part." It also works for flowers if body=flower center, spikes=petals and petals are smaller than the center.
#I'll probably make a superclass and subclasses for each subject when I have multiple subjects. 

from matplotlib import pyplot as plt
import math, cv2, numpy as np
from skimage import measure 
from skimage.measure import regionprops

#sample dragon sketch to color
#(and see below for test image code for this and other images)
dragon=cv2.imread('Dragon.bmp',0)
plt.imshow(dragon, cmap = 'gray', interpolation = 'bicubic')
plt.xticks([]), plt.yticks([])  # to hide tick values on X and Y axis
plt.show()

class SketchComponents:
    #Part of project DragonPaint
    #The goal of SketchComponents is to do as well as we can in autopainting without machine learning to 
    #minimize (goal=zero or one) the number of training images that will have to be manually painted for the ML training set.

    #SketchComponents contains component based autopainting methods for "good sketches" to partially automate the creation 
    #of a training set for a machine learning GAN based autopainting program based on Isola, et. al's 
    #Image to Image Translation with Conditional Adversarial Nets. 
    
    #SketchComponents stores image and uses component information (area, color, distance between components) to 
    #label and color sketch parts of image according to a part coloring map, e.g. color dragon body green, 
    #spikes yellow and leave eyes white or color flower center orange and petals yellow.
    
    #Image = black line cartoon sketch on white background from "Paint" program with well connected lines 
    #and certain geometric relationships (e.g. background bigger than body and body bigger than any other dragon part).
    
    def __init__(self,image):
        #Finds white components, background, body and line width at init. Finding distance between components 
        #Depending on incoming data, might want to change to grayscale or scale to standard size here.
        
        #store sketch image
        self.image=image
        #find connected components
        self.labelComponents()
        #find white components
        self.setWhiteLabels()
        #background and body are largest and second largest white components
        self.backgroundLabel,self.bodyLabel=self.setBackgroundAndBody()
        #placeholder values for lineWidth and matrix of distances between components
        #will be set if/when we calculate component distances - a slow calculation and not needed for all applications
        self.lineWidth=-1 
        self.D=[] 
    
    #LABEL CONNECTED COMPONENTS
    def labelComponents(self):
        #We want only black and white (no gray) for components to work as intended so binary threshold
        ret,self.thresh1 = cv2.threshold(self.image,200,255,cv2.THRESH_BINARY) 
        self.labels=measure.label(self.thresh1,background=-1)
        self.regions=regionprops(self.labels)
        self.numRegions=len(self.regions)       
        
    #BACKGROUND V. BODY V. SPIKES+ for dragons
    #(OR BACKGROUND V. CENTERS V. PETALS for flowers)
    
    #Use components' size and color (white) to distinguish between background, body and spikes+.
    #The largest white component is background. The second largest is body. 
    #The rest of the white components are spikes or other and we'll differentiate them in other methods.
    
    def setWhiteLabels(self):
        #make list of labels of white components
        self.whiteLabels=[]
        for i in range(self.numRegions):
            row,column=self.regions[i].coords[0][0],self.regions[i].coords[0][1]
            if(self.thresh1[row][column]==255):
                self.whiteLabels.append(self.regions[i].label)
        
    def setBackgroundAndBody(self):
        #Make a list of sizes of white components and then sort to get biggest and second biggest.
        #If I later decide I need the whiteSize list for something, save it here.
        whiteSize=[]
        for label in self.whiteLabels:
            whiteSize.append(self.regions[label-1].area)
        sizeSorted=sorted(whiteSize,reverse=True)
        biggestSize=sizeSorted[0]
        secondBiggestSize=sizeSorted[1] 
        #find labels for two biggest white components, background and body; save
        backgroundLabel=-1
        bodyLabel=-1
        for label in self.whiteLabels:
            if self.regions[label-1].area==biggestSize:
                backgroundLabel=label
            if self.regions[label-1].area==secondBiggestSize:
                if label!=backgroundLabel:
                    bodyLabel=label
        return backgroundLabel, bodyLabel            
    
    #SPIKES V. EYE
    #dragon only; not needed for flowers
    #Use distance between components.
    #Eye is in interior of body, spikes are on the edge.
    #Relationships true in sample sketches: dist(eye,background)>3*lineWidth and dist(eye,body)<2*lineWidth
    #Note that eye may have multiple white components but distance to background > 3*lineWidth holds for all of them.
    #We can get line width from distance between body and background: lineWidth=dist(body,background)
    #Eyelid (for another method): if sketch has eyelid, it will be captured here as part of eye. To color it e.g. 
    #body color, use y-value to separate it if you know you have eyelid. If you don't know, maybe find a way to 
    #recognize the lines crossing in X's. 

    #Define component distance methods and compute distance matrix.
    def Euc2(self,point1,point2):
        a=(point1[0]-point2[0])**2
        b=(point1[1]-point2[1])**2
        return a+b

    def calcCompDistance(self,i,j):
        #Calculate Euclidean distance between components with labels i and j.
        #Note component with label i is at index i-1
        point1=self.regions[i-1].coords[0]
        point2=self.regions[j-1].coords[0]
        minDist=self.Euc2(point1,point2)
        for point2 in self.regions[j-1].coords:
            for point1 in self.regions[i-1].coords:
                minDist=min(minDist,self.Euc2(point1,point2))
        return math.sqrt(minDist)
    
    def computeCompDistMatrix(self):
        #Compute component distance matrix - entry at i,j is distance between regions labeled i+1 and j+1.
        #This is a slow calculation - look for a better way.
        componentDist=np.zeros((self.numRegions,self.numRegions))
        for i in range(self.numRegions):
            componentDist[i][i]=0
            for j in range(i+1,self.numRegions):
                componentDist[i][j]=self.calcCompDistance(i+1,j+1)
                componentDist[j][i]=componentDist[i][j]
        self.D=componentDist
    
    def getComponentDistance(self,i,j):
        if i<=0 or j<=0 or i>self.numRegions or j>self.numRegions:
            return -1
        elif len(self.D)==0:
            self.computeCompDistMatrix()
        return self.D[i-1][j-1]
    
    def setLineWidth(self):
        self.lineWidth=self.getComponentDistance(self.bodyLabel,self.backgroundLabel)
    
    def setEyeSpikes(self):
        #Use this to find the eye in the body/to distinguish eye from spike.
        #I assume interior components (components a min distance from the background) are the eye which assumes that 
        #only the eye is interior but if we have other interior points in the body or in another component, we'll need 
        #to distinguish between the cases. I assume at least for now that everything else is a spike.
        interiorWhiteLabels=[]
        spikes=[]
        if self.lineWidth==-1:
            self.setLineWidth()
        for label in self.whiteLabels:
            if label!=self.backgroundLabel and label!=self.bodyLabel:
                if self.getComponentDistance(label,self.backgroundLabel)>2*self.lineWidth:
                    interiorWhiteLabels.append(label)
                else:
                    spikes.append(label)
        self.spikes=spikes        
        self.eye=interiorWhiteLabels
            
    #Note - I need to think about how to make Spike. v. Eye faster. The component distance calculation is computationally
    #expensive. A possible faster algorithm for Spike v. Eye is to expand region around spike/eye by 2*lineWidth and ask if 
    #that intersects with background. If not, eye. If yes, spike. 
    #I'll probably want distance between components for other things though, e.g. to distinguish spikes as a longer 
    #'chain of close things' than claws. Look again for component distance already implemented in Python library. 
    
    class TestSketch:
    #Tests for SketchComponents
    
    def testSketches(self,numTest):

        #tests 0,1,2 for testing BACKGROUND v. BODY
        if numTest==0:
            #Make small array with three components plus background.
            img=np.zeros((5,5), dtype=np.uint8)
            c1=[[0,0],[0,1],[1,0]]
            c2=[[1,1]]
            c3=[[3,4],[4,4],[3,1]]
            c=c1+c2+c3
            for (p1,p2) in c:
                img[p1,p2]=255
            return img

        if numTest==1:
            #Make small black circle on white background.
            # Create a black image, turn it white and draw black circle.
            img = np.zeros((15,15), dtype=np.uint8)
            img[:] = 255
            #cv2.circle(img, center, radius, color, thickness=1, lineType=8, shift=0)
            #Can change line type to get antialiased, default isn't; negative thickness is solid disk.
            cv2.circle(img,(7,7),5,0,2)
            return img

        if numTest==2:
            #Make two concentric black circles on white background.
            # Create a black image, turn it white and draw black circles.
            img = np.zeros((60,60), dtype=np.uint8)
            img[:] = 255
            #cv2.circle(img, center, radius, color, thickness=1, lineType=8, shift=0)
            #Can change line type to get antialiased, default isn't; negative thickness is solid disk.
            cv2.circle(img,(30,30),17,0,2)
            cv2.circle(img,(30,30),7,0,2)
            return img
        
        if numTest==3:
            #read in a sample scaled down dragon sketch, Dragon200x200.bmp
            img=cv2.imread('Dragon200x200.bmp',0)
            cv2.imshow('image from file',img)
            cv2.waitKey(0)
            cv2.destroyAllWindows()
            return img
 
        if numTest==4:
            #read in full dragon sketch, Dragon.bmp
            img=cv2.imread('Dragon.bmp',0)
            cv2.imshow('image from file',img)
            cv2.waitKey(0)
            cv2.destroyAllWindows()
            return img
    
    def printTestBackgroundBody(self,numTest):
        #tests component labels, size, background and body labels 
        sketch=SketchComponents(self.testSketches(numTest))
        print('image')
        print(sketch.image)
        print('thresh1')
        print(sketch.thresh1)
        print('labels')
        print(sketch.labels)
        print('numRegions',sketch.numRegions)
        print('whiteLabels',sketch.whiteLabels)
        for region in sketch.regions:
            print('label',region.label,'area',region.area)
        print('backgroundLabel',sketch.backgroundLabel)
        print('bodyLabel',sketch.bodyLabel)
        return sketch
    
    def printTestEyeSpikes(self,numTest):
        #do testBackgroundBody first so you know it works
        #the component distance computations are very slow for sketches - think about how to make them faster
        sketch=SketchComponents(self.testSketches(numTest))
        sketch=self.printTestBackgroundBody(numTest)
        sketch.setEyeSpikes()
        print('sketch.lineWidth',sketch.lineWidth)
        print('sketchD')
        print(sketch.D)
        print('sketch.eye',sketch.eye)
        print('sketch.spikes',sketch.spikes)
        
